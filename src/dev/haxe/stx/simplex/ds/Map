package stx.coroutine.pack.Coroutine.ds;

import fig.Variable;

typedef MapCoroutine<K,V> = stx.coroutine.pack.Coroutine<MapInput<K,V>,MapOutput<K,V>,Any>;

enum MapInput<K,V>{
  Set(k:K,v:V);
  Get(k:K);
}
typedef MapOutput<K,V> = Array<Variable<K,V>>;


@:forward abstract Map<K,V>(MapCoroutine<K,V>) from MapCoroutine<K,V> to MapCoroutine<K,V>{
  public function new(zero:Void->std.Map<K,V>):MapCoroutine<K,V>{
    function copy(map:std.Map<K,V>):std.Map<K,V>{
      var next_map = zero();
      for(key in map.keys()){
        next_map.set(key,map.get(key));
      }
      return next_map;
    }
    return Wait(
      function waiting(map:std.Map<K,V>,ipt:MapInput<K,V>):MapCoroutine<K,V>{
        return switch(ipt){
          case Set(k,v) :
            var next = copy(map);
                next.set(k,v);
            Wait(waiting.bind(next));
          case Get(k) :
            var val                      = thx.Options.toOption(map.get(k));
            var op  : MapCoroutine<K,V>    = Wait(waiting.bind(map));
            var out : MapOutput<K,V>     = [tuple2(k,val)];
            Emit(out,op);
        }
      }.bind(zero())
    );
  }
}
